<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PERSONALIZED_PAGERANK // DITHERPUNK_RESPONSIVE</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        :root {
            --matrix-green: #00FF00;
            --void-black: #000000;
            --ui-width: 300px;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--void-black);
            color: var(--matrix-green);
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden; /* Prevent scroll on mobile */
        }

        /* Scanline CRT effect */
        body::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 10;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        canvas {
            display: block;
            image-rendering: pixelated; 
        }

        /* Responsive UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            /* Adaptive width */
            width: var(--ui-width);
            max-width: calc(100vw - 40px); 
            padding: 15px;
            border: 2px solid var(--matrix-green);
            background-color: var(--void-black);
            z-index: 20;
            box-shadow: 4px 4px 0px var(--matrix-green);
            /* Prevent UI from becoming too tall on small landscapes */
            max-height: 90vh;
            overflow-y: auto;
        }

        /* Mobile adjustment */
        @media (max-width: 600px) {
            #ui-layer {
                top: 10px;
                left: 10px;
                padding: 10px;
                font-size: 0.9em;
            }
        }

        h1 {
            font-size: 16px;
            margin: 0 0 15px 0;
            border-bottom: 1px dashed var(--matrix-green);
            padding-bottom: 5px;
            text-transform: uppercase;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            font-size: 12px;
            margin-bottom: 5px;
            font-weight: bold;
        }

        /* Retro Slider */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }

        input[type=range]:focus {
            outline: none;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            background: var(--matrix-green);
            cursor: pointer;
            border: 2px solid var(--void-black);
            margin-top: -6px;
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: #003300;
            border: 1px solid var(--matrix-green);
        }

        /* Retro Button */
        button {
            width: 100%;
            padding: 10px;
            background: var(--void-black);
            border: 2px solid var(--matrix-green);
            color: var(--matrix-green);
            font-family: inherit;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.1s;
        }

        button:hover {
            background: var(--matrix-green);
            color: var(--void-black);
        }

        button.active {
            background: var(--matrix-green);
            color: var(--void-black);
            box-shadow: inset 2px 2px 0px rgba(0,0,0,0.5);
        }

        .status-line {
            font-size: 10px;
            margin-top: 5px;
            opacity: 0.8;
            display: flex;
            justify-content: space-between;
        }

        .legend {
            margin-top: 15px;
            font-size: 10px;
            border-top: 1px dashed var(--matrix-green);
            padding-top: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
        }
        
        .legend-box {
            width: 10px;
            height: 10px;
            min-width: 10px; /* Prevent shrink */
            margin-right: 8px;
            border: 1px solid var(--matrix-green);
        }

        #tooltip {
            margin-top: 10px;
            font-size: 11px;
            font-style: italic;
            color: #00AA00;
        }

    </style>
</head>
<body>

    <div id="ui-layer">
        <h1>PPR_VIS // DITHERPUNK</h1>
        
        <div class="control-group">
            <label>MODE SELECT:</label>
            <button id="btn-toggle" onclick="toggleMode()">MODE: GLOBAL</button>
        </div>

        <div class="control-group">
            <label>TELEPORT PROBABILITY (&alpha;): <span id="alpha-val">0.15</span></label>
            <input type="range" id="alpha-slider" min="0.01" max="0.50" step="0.01" value="0.15">
        </div>

        <div class="control-group">
            <div class="status-line"><span>ACTIVE_SURFERS:</span> <span id="particle-count">0</span></div>
            <div class="status-line"><span>TELEPORTS/SEC:</span> <span id="teleport-rate">0</span></div>
            <div class="status-line"><span>SOURCE_NODES:</span> <span id="source-count">0</span></div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-box" style="background: var(--matrix-green)"></div>
                <span>SOURCE (Restart Point)</span>
            </div>
            <div class="legend-item">
                <div class="legend-box"></div>
                <span>TARGET NODE</span>
            </div>
            <div class="legend-item">
                <div style="width:10px; height:10px; margin-right:8px; display:flex; justify-content:center; align-items:center;">
                    <div style="width:2px; height:2px; background:var(--matrix-green)"></div>
                </div>
                <span>INFLUENCE PARTICLE</span>
            </div>
        </div>
        
        <div id="tooltip"> > TAP NODES TO TOGGLE SOURCE</div>
    </div>

    <div id="canvas-container">
        <canvas id="simCanvas"></canvas>
    </div>

<script>
/**
 * DITHERPUNK PERSONALIZED PAGERANK VISUALIZATION
 * WINDOW-SIZE AGNOSTIC VERSION
 */

// --- CONFIGURATION ---
const CONFIG = {
    nodeCount: 25,
    particleCount: 600, // Reduced slightly for mobile performance
    nodeRadius: 15,
    minSpeed: 0.01,
    maxSpeed: 0.03,
    color: '#00FF00',
    bg: '#000000'
};

// --- STATE ---
let nodes = [];
let links = [];
let particles = [];
let isPersonalized = false;
let alpha = 0.15;
let teleportCounter = 0;

// --- DOM ELEMENTS ---
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
const alphaSlider = document.getElementById('alpha-slider');
const alphaDisplay = document.getElementById('alpha-val');
const btnToggle = document.getElementById('btn-toggle');
const sourceCountDisp = document.getElementById('source-count');
const particleCountDisp = document.getElementById('particle-count');
const teleportRateDisp = document.getElementById('teleport-rate');

// --- PHYSICS SIMULATION (D3) ---
// Defined early so we can update it in resize()
let simulation;

// --- INITIALIZATION & RESIZE HANDLING ---

function init() {
    initGraph();
    initParticles();
    
    // Create D3 Simulation
    simulation = d3.forceSimulation(nodes)
        .force("link", d3.forceLink(links).id(d => d.id).distance(80))
        .force("charge", d3.forceManyBody().strength(-200))
        .force("collide", d3.forceCollide(CONFIG.nodeRadius * 1.5))
        // Center force will be updated on resize
        .force("center", d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2));
    
    handleResize(); // Trigger initial sizing
    draw(); // Start loop
}

function handleResize() {
    // 1. Update Canvas Buffer
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // 2. Update Physics Center Force
    if (simulation) {
        simulation.force("center", d3.forceCenter(canvas.width / 2, canvas.height / 2));
        simulation.alpha(0.3).restart(); // Wake up sim to drift to new center
    }
}

window.addEventListener('resize', handleResize);

// --- GRAPH GENERATION ---
function initGraph() {
    // Generate Nodes
    for (let i = 0; i < CONFIG.nodeCount; i++) {
        nodes.push({
            id: i,
            // Initialize near center to avoid exploding from corner
            x: window.innerWidth / 2 + (Math.random() - 0.5) * 50,
            y: window.innerHeight / 2 + (Math.random() - 0.5) * 50,
            isSource: false,
            score: 0
        });
    }

    // Default Source
    nodes[0].isSource = true;

    // Generate Links (Clustered Topology)
    nodes.forEach((source, i) => {
        let targetIndex = Math.floor(Math.random() * CONFIG.nodeCount);
        while(targetIndex === i) targetIndex = Math.floor(Math.random() * CONFIG.nodeCount);
        
        links.push({ source: source.id, target: targetIndex });

        if (Math.random() > 0.6) {
            let t2 = Math.floor(Math.random() * CONFIG.nodeCount);
            if(t2 !== i) links.push({ source: source.id, target: t2 });
        }
    });
}

// --- PARTICLE SYSTEM ---
class Particle {
    constructor() {
        this.reset();
    }

    reset() {
        const startNode = nodes[Math.floor(Math.random() * nodes.length)];
        this.assignToNode(startNode);
        this.speed = CONFIG.minSpeed + Math.random() * (CONFIG.maxSpeed - CONFIG.minSpeed);
    }

    assignToNode(node) {
        this.currentEdge = this.pickEdge(node);
        this.pos = { x: node.x, y: node.y };
        
        // If sink (no edges), we consider the particle "stuck" at the node
        // In the update loop, this triggers an immediate teleport/reset
        if (!this.currentEdge) {
            this.targetNode = node; 
        } else {
            this.targetNode = this.currentEdge.target;
        }
        this.progress = 0;
    }

    pickEdge(node) {
        // D3 replaces link indices with object references. 
        // We filter links where source matches our current node object.
        const outgoing = links.filter(l => l.source === node);
        if (outgoing.length === 0) return null;
        return outgoing[Math.floor(Math.random() * outgoing.length)];
    }

    update() {
        // 1. Probabilistic Teleport (Damping Factor)
        if (Math.random() < alpha) {
            this.teleport();
            return;
        }

        // 2. Sink Handling
        if (!this.currentEdge) {
            this.teleport(); // Stuck particles must teleport
            return;
        }

        // 3. Movement
        this.progress += this.speed;
        
        const sx = this.currentEdge.source.x;
        const sy = this.currentEdge.source.y;
        const tx = this.currentEdge.target.x;
        const ty = this.currentEdge.target.y;

        this.pos.x = sx + (tx - sx) * this.progress;
        this.pos.y = sy + (ty - sy) * this.progress;

        // 4. Arrival
        if (this.progress >= 1.0) {
            const arrivalNode = this.currentEdge.target;
            
            // Accumulate Score
            arrivalNode.score = Math.min(arrivalNode.score + 0.05, 1.0); 

            // Next Hop
            this.assignToNode(arrivalNode);
        }
    }

    teleport() {
        teleportCounter++;
        
        if (isPersonalized) {
            const sources = nodes.filter(n => n.isSource);
            if (sources.length > 0) {
                const target = sources[Math.floor(Math.random() * sources.length)];
                target.score = 1.0; // Flash source
                this.assignToNode(target);
            } else {
                this.reset(); // Fallback
            }
        } else {
            // Global: Jump anywhere
            const target = nodes[Math.floor(Math.random() * nodes.length)];
            this.assignToNode(target);
        }
    }
}

function initParticles() {
    for (let i = 0; i < CONFIG.particleCount; i++) {
        particles.push(new Particle());
    }
}

// --- RENDERING ---

function drawDitheredCircle(x, y, radius, intensity, isSource) {
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.strokeStyle = CONFIG.color;
    ctx.lineWidth = 2;
    ctx.stroke();

    if (isSource) {
        // Inverted Source Style
        ctx.fillStyle = CONFIG.color;
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x, y, radius * 0.4, 0, Math.PI * 2);
        ctx.fillStyle = CONFIG.bg;
        ctx.fill();
        return;
    }

    // Stochastic Stippling (Dithering)
    // Scale pixel count by intensity (PPR score)
    const pixelCount = Math.floor((Math.PI * radius * radius) * 0.7 * intensity);
    
    ctx.fillStyle = CONFIG.color;
    for (let i = 0; i < pixelCount; i++) {
        // Random point inside circle
        const r = radius * Math.sqrt(Math.random()) * 0.9;
        const theta = Math.random() * 2 * Math.PI;
        ctx.fillRect(x + r * Math.cos(theta), y + r * Math.sin(theta), 1.5, 1.5);
    }
}

function draw() {
    // Clear
    ctx.fillStyle = CONFIG.bg;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Edges
    ctx.strokeStyle = '#004400';
    ctx.lineWidth = 1;
    ctx.beginPath();
    links.forEach(link => {
        ctx.moveTo(link.source.x, link.source.y);
        ctx.lineTo(link.target.x, link.target.y);
    });
    ctx.stroke();

    // Nodes
    nodes.forEach(node => {
        node.score *= 0.98; // Decay
        // Clamp radius for small screens
        const r = Math.min(CONFIG.nodeRadius + (node.score * 5), 30);
        drawDitheredCircle(node.x, node.y, r, node.score, node.isSource);
    });

    // Particles
    ctx.fillStyle = CONFIG.color;
    particles.forEach(p => {
        p.update();
        ctx.fillRect(p.pos.x - 1, p.pos.y - 1, 3, 3);
    });

    requestAnimationFrame(draw);
}

// --- INTERACTION ---

// Stats Loop
setInterval(() => {
    sourceCountDisp.innerText = nodes.filter(n => n.isSource).length;
    particleCountDisp.innerText = CONFIG.particleCount;
    teleportRateDisp.innerText = (teleportCounter * 2);
    teleportCounter = 0;
}, 500);

// Click Handler
canvas.addEventListener('mousedown', (e) => {
    // Get mouse pos relative to canvas
    // (Simple offset works here because canvas is full screen 0,0)
    const mx = e.clientX;
    const my = e.clientY;

    nodes.forEach(node => {
        const dist = Math.sqrt((mx - node.x)**2 + (my - node.y)**2);
        // Larger hit area for touch/click
        if (dist < 30) {
            node.isSource = !node.isSource;
            simulation.alpha(0.1).restart();
        }
    });
});

// Touch Handler for Mobile
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault(); // Prevent scrolling
    const touch = e.touches[0];
    const mx = touch.clientX;
    const my = touch.clientY;
    
    nodes.forEach(node => {
        const dist = Math.sqrt((mx - node.x)**2 + (my - node.y)**2);
        if (dist < 30) {
            node.isSource = !node.isSource;
            simulation.alpha(0.1).restart();
        }
    });
}, {passive: false});

// UI
alphaSlider.addEventListener('input', (e) => {
    alpha = parseFloat(e.target.value);
    alphaDisplay.innerText = alpha.toFixed(2);
});

function toggleMode() {
    isPersonalized = !isPersonalized;
    if (isPersonalized) {
        btnToggle.innerText = "MODE: PERSONALIZED";
        btnToggle.classList.add("active");
        nodes.forEach(n => n.score = 0);
    } else {
        btnToggle.innerText = "MODE: GLOBAL";
        btnToggle.classList.remove("active");
    }
}

// Boot
init();

</script>
</body>
</html>