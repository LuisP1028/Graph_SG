<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ALS Algorithm - Ditherpunk Visualization</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        :root {
            --bg: #000000;
            --fg: #00FF00;
            --gap: 1.5vmin;
        }

        * {
            box-sizing: border-box;
            font-family: 'VT323', 'Courier New', monospace;
            user-select: none;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg);
            color: var(--fg);
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        /* Responsive Square Wrapper */
        #visualization-wrapper {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #svg-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* Grid Layout matching Matrix Dimensions */
        .layout-grid {
            display: grid;
            grid-template-columns: 2.5fr 7.5fr;
            grid-template-rows: 2.5fr 7.5fr;
            gap: var(--gap);
            width: 90vmin;
            height: 90vmin;
            z-index: 5;
            position: relative;
        }

        /* Status Panel (Top Left) */
        #status-panel {
            grid-column: 1;
            grid-row: 1;
            border: 2px solid var(--fg);
            padding: 1.5vmin;
            font-size: 3vmin;
            text-transform: uppercase;
            text-shadow: 0 0 5px var(--fg);
            display: flex;
            align-items: flex-start;
            word-wrap: break-word;
            line-height: 1.2;
            background-color: var(--bg);
            position: relative;
        }
        
        .cursor {
            display: inline-block;
            width: 2vmin;
            height: 3vmin;
            background-color: var(--fg);
            animation: blink 1s step-end infinite;
            vertical-align: bottom;
            margin-left: 0.5vmin;
        }

        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

        /* Matrices Base Styles */
        .matrix {
            display: grid;
            gap: 0.5vmin;
            position: relative;
            transition: all 0.2s steps(2);
        }

        #matrix-v {
            grid-column: 2;
            grid-row: 1;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(3, 1fr);
        }

        #matrix-u {
            grid-column: 1;
            grid-row: 2;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(8, 1fr);
        }

        #matrix-r {
            grid-column: 2;
            grid-row: 2;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            border: 2px dashed var(--fg);
            padding: 0.5vmin;
        }

        /* Cells */
        .cell {
            border: 1px dotted var(--fg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5vmin;
            overflow: hidden;
            position: relative;
        }

        .matrix-u .cell, .matrix-v .cell {
            border-style: solid;
        }

        /* Sparse Matrix specific states */
        .cell.known {
            border: 1px solid var(--fg);
            font-weight: bold;
            text-shadow: 0 0 5px var(--fg);
        }
        
        .cell.known::before {
            content: '';
            position: absolute;
            inset: 0;
            background: url('data:image/svg+xml;utf8,<svg width="4" height="4" xmlns="http://www.w3.org/2000/svg"><rect width="4" height="4" fill="%23000"/><rect x="0" y="0" width="1" height="1" fill="%230f0"/></svg>');
            opacity: 0.5;
            z-index: -1;
        }

        .cell.high-prob {
            border: 2px solid var(--fg);
            animation: terminal-pulse 0.4s infinite alternate steps(3);
            font-weight: bold;
            z-index: 2;
        }

        @keyframes terminal-pulse {
            from { background-color: var(--bg); color: var(--fg); box-shadow: 0 0 5px var(--fg); }
            to { background-color: var(--fg); color: var(--bg); box-shadow: 0 0 15px var(--fg); }
        }

        /* Ditherpunk & ASCII Visual Effects */
        .dither-noise {
            animation: dither-flicker 0.1s infinite steps(2);
        }

        @keyframes dither-flicker {
            0% { background: url('data:image/svg+xml;utf8,<svg width="4" height="4" xmlns="http://www.w3.org/2000/svg"><rect width="4" height="4" fill="%23000"/><rect x="0" y="0" width="2" height="1" fill="%230f0"/><rect x="2" y="3" width="1" height="1" fill="%230f0"/><rect x="1" y="2" width="1" height="1" fill="%230f0"/></svg>'); }
            50% { background: url('data:image/svg+xml;utf8,<svg width="4" height="4" xmlns="http://www.w3.org/2000/svg"><rect width="4" height="4" fill="%23000"/><rect x="1" y="1" width="1" height="2" fill="%230f0"/><rect x="3" y="0" width="1" height="1" fill="%230f0"/><rect x="0" y="3" width="1" height="1" fill="%230f0"/></svg>'); }
            100% { background: url('data:image/svg+xml;utf8,<svg width="4" height="4" xmlns="http://www.w3.org/2000/svg"><rect width="4" height="4" fill="%23000"/><rect x="2" y="1" width="2" height="1" fill="%230f0"/><rect x="0" y="2" width="1" height="1" fill="%230f0"/><rect x="3" y="3" width="1" height="1" fill="%230f0"/></svg>'); }
        }

        .dither-25 { background: url('data:image/svg+xml;utf8,<svg width="4" height="4" xmlns="http://www.w3.org/2000/svg"><rect width="4" height="4" fill="%23000"/><rect x="0" y="0" width="1" height="1" fill="%230f0"/><rect x="2" y="2" width="1" height="1" fill="%230f0"/></svg>'); }
        .dither-50 { background: url('data:image/svg+xml;utf8,<svg width="2" height="2" xmlns="http://www.w3.org/2000/svg"><rect width="2" height="2" fill="%23000"/><rect x="0" y="0" width="1" height="1" fill="%230f0"/><rect x="1" y="1" width="1" height="1" fill="%230f0"/></svg>'); }
        .dither-75 { background: url('data:image/svg+xml;utf8,<svg width="4" height="4" xmlns="http://www.w3.org/2000/svg"><rect width="4" height="4" fill="%230f0"/><rect x="1" y="1" width="1" height="1" fill="%23000"/><rect x="3" y="3" width="1" height="1" fill="%23000"/></svg>'); }

        /* Algorithm States */
        .locked::after {
            content: '[X] FROZEN';
            position: absolute;
            inset: -4px;
            background: url('data:image/svg+xml;utf8,<svg width="4" height="4" xmlns="http://www.w3.org/2000/svg"><rect width="4" height="4" fill="none"/><rect x="0" y="0" width="1" height="1" fill="%230f0"/><rect x="2" y="2" width="1" height="1" fill="%230f0"/></svg>');
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4vmin;
            font-weight: bold;
            color: var(--bg);
            text-shadow: -1px -1px 0 var(--fg), 1px -1px 0 var(--fg), -1px 1px 0 var(--fg), 1px 1px 0 var(--fg);
            z-index: 10;
            border: 2px solid var(--fg);
        }

        .updating {
            box-shadow: 0 0 20px var(--fg), inset 0 0 10px var(--fg);
            border: 2px solid var(--fg);
            z-index: 6;
        }

        /* SVG Beams */
        .beam {
            stroke: var(--fg);
            stroke-width: 2px;
            fill: none;
            stroke-dasharray: 8 4;
            animation: beam-flow 0.5s linear infinite;
            filter: drop-shadow(0 0 4px var(--fg));
        }

        @keyframes beam-flow {
            to { stroke-dashoffset: -12; }
        }
    </style>
</head>
<body>

    <div id="visualization-wrapper">
        <svg id="svg-layer"></svg>
        
        <div class="layout-grid">
            <div id="status-panel">
                <span id="status-text">> SYSTEM_BOOT...</span><span class="cursor"></span>
            </div>
            
            <div id="matrix-v" class="matrix matrix-v"></div>
            <div id="matrix-u" class="matrix matrix-u"></div>
            <div id="matrix-r" class="matrix matrix-r"></div>
        </div>
    </div>

    <script>
        const R_SIZE = 8;
        const K_SIZE = 3;
        
        const knownCells = [];
        const icons = ['[+]', '[*]', '< >', '[@]', '(#)'];

        const domV = document.getElementById('matrix-v');
        const domU = document.getElementById('matrix-u');
        const domR = document.getElementById('matrix-r');
        const svgLayer = document.getElementById('svg-layer');
        const statusText = document.getElementById('status-text');

        let currentBeamsState = null; // Used to redraw on resize

        const sleep = ms => new Promise(res => setTimeout(res, ms));

        // Initialization Logic
        function initDOM() {
            domV.innerHTML = '';
            domU.innerHTML = '';
            domR.innerHTML = '';
            knownCells.length = 0;

            // Generate 10 random unique known cells for R
            while (knownCells.length < 10) {
                let r = Math.floor(Math.random() * R_SIZE);
                let c = Math.floor(Math.random() * R_SIZE);
                if (!knownCells.find(x => x.r === r && x.c === c)) {
                    knownCells.push({ r, c, icon: icons[Math.floor(Math.random() * icons.length)] });
                }
            }

            // Create Items Matrix (V): 3 rows x 8 cols
            for (let k = 0; k < K_SIZE; k++) {
                for (let c = 0; c < R_SIZE; c++) {
                    let cell = document.createElement('div');
                    cell.className = 'cell v-cell dither-noise';
                    cell.id = `V-${k}-${c}`;
                    domV.appendChild(cell);
                }
            }

            // Create Users Matrix (U): 8 rows x 3 cols
            for (let r = 0; r < R_SIZE; r++) {
                for (let k = 0; k < K_SIZE; k++) {
                    let cell = document.createElement('div');
                    cell.className = 'cell u-cell dither-noise';
                    cell.id = `U-${r}-${k}`;
                    domU.appendChild(cell);
                }
            }

            // Create Sparse Matrix (R): 8 rows x 8 cols
            for (let r = 0; r < R_SIZE; r++) {
                for (let c = 0; c < R_SIZE; c++) {
                    let cell = document.createElement('div');
                    cell.className = 'cell r-cell';
                    cell.id = `R-${r}-${c}`;
                    
                    let known = knownCells.find(x => x.r === r && x.c === c);
                    if (known) {
                        cell.classList.add('known');
                        cell.innerText = known.icon;
                    }
                    domR.appendChild(cell);
                }
            }
        }

        function setStatus(text) {
            statusText.innerText = text;
        }

        // Action Utilities
        function toggleLock(matrixId, isLocked) {
            const el = document.getElementById(`matrix-${matrixId}`);
            if (isLocked) el.classList.add('locked');
            else el.classList.remove('locked');
        }

        function toggleActive(matrixId, isActive) {
            const el = document.getElementById(`matrix-${matrixId}`);
            if (isActive) el.classList.add('updating');
            else el.classList.remove('updating');
        }

        function setMatrixDither(matrixId, type) {
            const cells = document.querySelectorAll(`.${matrixId}-cell`);
            cells.forEach(c => {
                c.classList.remove('dither-noise', 'dither-25', 'dither-50', 'dither-75');
                if (type === 'noise') {
                    c.classList.add('dither-noise');
                } else if (type === 'static') {
                    const r = Math.random();
                    if (r < 0.33) c.classList.add('dither-25');
                    else if (r < 0.66) c.classList.add('dither-50');
                    else c.classList.add('dither-75');
                }
            });
        }

        function clearR() {
            const cells = document.querySelectorAll('.r-cell');
            cells.forEach(c => {
                if (!c.classList.contains('known')) {
                    c.className = 'cell r-cell';
                    c.innerText = '';
                }
            });
        }

        // Beams & Drawing logic
        function getCenter(el) {
            const rect = el.getBoundingClientRect();
            return {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };
        }

        function drawBeams(direction) {
            svgLayer.innerHTML = '';
            currentBeamsState = direction;

            // Map standard K center index to route beams nicely
            const kCenter = Math.floor(K_SIZE / 2);

            knownCells.forEach(kc => {
                // Find corresponding DOM nodes
                const rCell = document.getElementById(`R-${kc.r}-${kc.c}`);
                const vCell = document.getElementById(`V-${kCenter}-${kc.c}`); // mid column cell in V
                const uCell = document.getElementById(`U-${kc.r}-${kCenter}`); // mid row cell in U

                if (rCell && vCell && uCell) {
                    const pR = getCenter(rCell);
                    const pV = getCenter(vCell);
                    const pU = getCenter(uCell);

                    const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
                    polyline.classList.add('beam');

                    if (direction === 'toUsers') {
                        // V -> R -> U
                        polyline.setAttribute('points', `${pV.x},${pV.y} ${pR.x},${pR.y} ${pU.x},${pU.y}`);
                    } else {
                        // U -> R -> V
                        polyline.setAttribute('points', `${pU.x},${pU.y} ${pR.x},${pR.y} ${pV.x},${pV.y}`);
                    }
                    svgLayer.appendChild(polyline);
                }
            });
        }

        function clearBeams() {
            svgLayer.innerHTML = '';
            currentBeamsState = null;
        }

        // Handle resizing while drawing beams
        window.addEventListener('resize', () => {
            if (currentBeamsState) drawBeams(currentBeamsState);
        });

        // Matrix Prediction Fill
        function predictBlanks() {
            const cells = document.querySelectorAll('.r-cell:not(.known)');
            const newlyFilled = [];
            
            cells.forEach(c => {
                const r = Math.random();
                if (r < 0.33) c.classList.add('dither-25');
                else if (r < 0.66) c.classList.add('dither-50');
                else c.classList.add('dither-75');
                newlyFilled.push(c);
            });

            // Highlight high probabilities
            for (let i = 0; i < 3; i++) {
                const target = newlyFilled[Math.floor(Math.random() * newlyFilled.length)];
                if (target) {
                    target.classList.add('high-prob');
                    target.innerText = '[!]';
                }
            }
        }

        // Main Animation State Machine Loop
        async function runALSAnimation() {
            while (true) {
                // PHASE 1: INIT
                setStatus("> INIT: SPARSE_MATRIX. LOAD...");
                toggleLock('v', false); toggleLock('u', false);
                toggleActive('v', false); toggleActive('u', false);
                initDOM();
                clearBeams();
                await sleep(2500);

                // PHASE 2: Freeze V, Update U
                setStatus("> STEP_1: FREEZE ITEMS. UPDATE USERS.");
                toggleLock('v', true);
                toggleActive('u', true);
                setMatrixDither('u', 'noise');
                drawBeams('toUsers');
                await sleep(3000);
                setMatrixDither('u', 'static');
                await sleep(1000);

                // PHASE 3: Freeze U, Update V
                setStatus("> STEP_2: FREEZE USERS. UPDATE ITEMS.");
                clearBeams();
                toggleLock('v', false);
                toggleActive('u', false);
                
                toggleLock('u', true);
                toggleActive('v', true);
                setMatrixDither('v', 'noise');
                drawBeams('toItems');
                await sleep(3000);
                setMatrixDither('v', 'static');
                await sleep(1000);

                // PHASE 4: Loop & Refine (Fast Alternating)
                setStatus("> LOOP: OPTIMIZING LATENT VECTORS...");
                clearBeams();
                for (let i = 0; i < 4; i++) {
                    const isUEven = (i % 2 === 0);
                    toggleLock('u', !isUEven);
                    toggleLock('v', isUEven);
                    toggleActive('u', isUEven);
                    toggleActive('v', !isUEven);
                    await sleep(600);
                }

                // PHASE 5: Reveal
                setStatus("> RESOLVE: DOT_PRODUCT MULTIPLICATION.");
                toggleLock('u', false);
                toggleLock('v', false);
                toggleActive('u', true);
                toggleActive('v', true);
                await sleep(800);
                
                setStatus("> PREDICTION GENERATED: RECOMMENDATIONS READY.");
                toggleActive('u', false);
                toggleActive('v', false);
                predictBlanks();
                await sleep(5000);

                // RESET
                setStatus("> RESTARTING SEQUENCE...");
                await sleep(1000);
            }
        }

        // Start 
        initDOM();
        setTimeout(runALSAnimation, 500);

    </script>
</body>
</html>